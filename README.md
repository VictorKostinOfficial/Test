# Вопрос №1:
При использовании `&` для определения четности числа, мы проверяем только наименьший бит числа. Если наименьший бит равен `0`, то число четное.

При использовании `%` для определения четности числа, мы делим целое число и проверяем только остаток. Если остаток равен `0`, то число четное.

В случае с `%` стоит помнить что при делении отрицательных чисел, мы получем отрицательное число. Если `-1 % 2`, то результат равен `-1`. Следовательно можно допустить ошибку, выражение `return x % 2 != 1` будет выдавать неверное значение для отрицательных чисел.

Стоит помнить, что современные компиляторы могу оптимизировать оба варианта так, что эффективность обоих выражении будет одинакова.

# Вопрос №2:
## Реализания на std::vector
### Минусы:
- Имеет ограничение `тип V должен иметь конструктор без параметров`.
- Использует весь объем памяти, даже если в буфере 1 элемент. Сделано для того чтобы не копировать полностью массив при удалении данных из начала массива.
### Плюсы:
- Инициирует память один раз и переиспользует ее.
- Меньшее потребление памяти при большом кол-ве элементов буфере
## Реализация на std::list
### Минусы:
- элементы std::list хранят в себе дополнительные данные, такие как, указатели на предыдущий и следующий объект, что приводит к большему потреблению памяти при большом кол-ве элементов в буфере.
### Плюсы:
- динамически расширяемый, не хранит в себе лишнее данные.

# Вопрос №3:
Был выбран алгоритм `Merge Sort`. Big O = `O(n log(n))`. 

Алгоритм имеет одинаковую сложность на массивах различного размера как со случайным, так и с отсортированным порядком чисел. 
Может уступать на маленьких массивах другим алгоритмам, например `Quick Sort`.

Так же его можно запустить на нескольких потоках, что тоже даст ускорение.

Моя реализация использует дополнительную память для сортировки, есть реализации на C++17 с in-place сортировкой через std::inplace_merge, которая использует меньше памяти.
